#+title: Dasy

#+begin_quote
The Dasypeltis, gansi, is considered an egg-eating snake. Their diet consists of all forms of eggs considering they have no teeth in which to eat living prey with.
#+end_quote

Dasy is a smart contract programming language in the lisp family. It is implemented by compiling to Vyper and benefits from the extensive optimizations and excellent performance of Vyper.

Learn more in the [[file:docs.org][documentation]]

* Examples
[[file:examples][More examples]]
#+begin_src clojure
(defvars myMap (public (hash-map :address :uint256))
        nums (public (dyn-arr :uint256 3))
        owner (public :address))

(defn __init__ [] :external
  (setv self/owner msg/sender)
  (set-at self/myMap msg/sender 10)
  (do ;; wrap statements in do
    (.append self/nums 11)))

(defn getOwnerNum [] :uint256 :external
  (get-in self/myMap self/owner))
#+end_src

via [[https://github.com/z80dev/titanoboa][this fork of titanoboa]]
#+begin_src python
import boa

c = boa.load("hello_world.dasy")
print(c.addUints(10, 20)) # outputs 30
print(c.subUints(100, 20)) # outputs 80
c.setBase(10)
print(c.addToBase(10)) # outputs 20
#+end_src

via hy (lisp based on python)
#+begin_src hy
(import rich [print]
        boa.contract [VyperContract]
        dasy)

(let [src (with [f (open "hello_world.dasy" "r")]
            (.read f))
      compilation_data (.compile dasy src)
      contract (VyperContract compilation_data)]
  (print f"calling (.addUints contract 10 20): {(.addUints contract 10 20)}")
  (print f"calling (.subUints contract 10 20): {(.subUints contract 100 20)}"))
#+end_src

Command line compilation
#+begin_src shell
> dasy hello_world.dasy
0x61004f61000f60003961004f6000f36003361161000c57610037565b60003560e01c3461003d5763c29855788118610035576004361861003d57600860405260206040f35b505b60006000fd5b600080fda165767970657283000306000b
#+end_src
* Installation
For use as a library
#+begin_src bash
pip install dasy
#+end_src

For use as an executable
#+begin_src bash
pipx install dasy
#+end_src
* Motivation
** Macros
There's a lot of opportunities for macros in smart contracts. They could also be used as a proof of concept for features before implementing them at a lower level in the compiler.

some example dasy macros:
#+begin_src lisp
(defmacro set-in [array index new-val] `(setv (subscript ~array ~index) ~new-val))
(defmacro hash-map [key-type val-type] `(subscript HashMap (tuple ~key-type ~val-type)))
(defmacro dyn-arr [type length] `(subscript DynArray (tuple ~type ~length)))
#+end_src

The macro's inner body would be made up of a pre-initialized for-loop.
** For fun
