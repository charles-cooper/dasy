#+title: Dasy

#+begin_quote
The Dasypeltis, gansi, is considered an egg-eating snake. Their diet consists of all forms of eggs considering they have no teeth in which to eat living prey with.
#+end_quote

Dasy is an experimental smart contract programming language in the lisp family. It is implemented by compiling to Vyper and benefits from the extensive optimizations and excellent performance of Vyper.

Learn more in the [[file:docs.org][documentation]]

* Examples
[[file:dasybyexample.md][More examples]]
#+begin_src clojure
(defvars myMap (public (hash-map :address :uint256))
        nums (public (dyn-arr :uint256 3))
        owner (public :address))

(defn __init__ [] :external
  (setv self/owner msg/sender)
  (set-at self/myMap msg/sender 10)
  (do ;; wrap statements in do
    (.append self/nums 11)))

(defn getOwnerNum [] :uint256 :external
  (get-in self/myMap self/owner))
#+end_src

via [[https://github.com/z80dev/titanoboa][this fork of titanoboa]]
#+begin_src python
import boa

c = boa.load("hello_world.dasy")
print(c.addUints(10, 20)) # outputs 30
print(c.subUints(100, 20)) # outputs 80
c.setBase(10)
print(c.addToBase(10)) # outputs 20
#+end_src

via hy (lisp based on python)
#+begin_src hy
(import rich [print]
        boa.contract [VyperContract]
        dasy)

(let [src (with [f (open "hello_world.dasy" "r")]
            (.read f))
      compilation_data (.compile dasy src)
      contract (VyperContract compilation_data)]
  (print f"calling (.addUints contract 10 20): {(.addUints contract 10 20)}")
  (print f"calling (.subUints contract 10 20): {(.subUints contract 100 20)}"))
#+end_src

Command line compilation
#+begin_src shell
> dasy hello_world.dasy
0x61004f61000f60003961004f6000f36003361161000c57610037565b60003560e01c3461003d5763c29855788118610035576004361861003d57600860405260206040f35b505b60006000fd5b600080fda165767970657283000306000b
#+end_src
* Installation
For use as a library
#+begin_src bash
pip install dasy
#+end_src

For use as an executable
#+begin_src bash
pipx install dasy
#+end_src
* Motivation
** Macros
There's a lot of opportunities for macros in smart contracts. They could also be used as a proof of concept for features before implementing them at a lower level in the compiler.

macros are written in Hy, a pythonic lisp. They allow us to transform our code at compile time, allowing the developer to tailor the language itself to their needs.

A basic example is =doto=
#+begin_src lisp
;;raw dasy
(do
  (.append self/nums 10)
  (.append self/nums 11)
  (.append self/nums 12)
  (.append self/nums 13)
  (.append self/nums 14))

;; macro definition
(defmacro doto [ obj #*cmds]
  `(do
     ~@(lfor c cmds
             `(~(get c 0) ~obj ~(get c 1)))))

;; using macro
(doto self/nums
  (.append 10)
  (.append 11)
  (.append 12)
  (.append 13)
  (.append 14))
#+end_src

After defining the =doto= macro, we are able to write shorter, simpler code which is easier to check for correctness.

** For fun
